<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="hr" xml:lang="hr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Reprezentacija teksta</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="txt Reprezentacija teksta_files/libs/clipboard/clipboard.min.js"></script>
<script src="txt Reprezentacija teksta_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="txt Reprezentacija teksta_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="txt Reprezentacija teksta_files/libs/quarto-html/popper.min.js"></script>
<script src="txt Reprezentacija teksta_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="txt Reprezentacija teksta_files/libs/quarto-html/anchor.min.js"></script>
<link href="txt Reprezentacija teksta_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="txt Reprezentacija teksta_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="txt Reprezentacija teksta_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="txt Reprezentacija teksta_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="txt Reprezentacija teksta_files/libs/bootstrap/bootstrap-813c323200a87c37e262811031999de4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#reprezentacija-teksta" id="toc-reprezentacija-teksta" class="nav-link active" data-scroll-target="#reprezentacija-teksta">Reprezentacija teksta</a>
  <ul class="collapse">
  <li><a href="#bag-of-words-bow-vreća-riječi" id="toc-bag-of-words-bow-vreća-riječi" class="nav-link" data-scroll-target="#bag-of-words-bow-vreća-riječi">Bag-of-Words (BoW) – Vreća riječi</a></li>
  <li><a href="#tf-idf-term-frequency-inverse-document-frequency" id="toc-tf-idf-term-frequency-inverse-document-frequency" class="nav-link" data-scroll-target="#tf-idf-term-frequency-inverse-document-frequency">TF-IDF (Term Frequency – Inverse Document Frequency)</a></li>
  <li><a href="#matrica-supojavljivanja" id="toc-matrica-supojavljivanja" class="nav-link" data-scroll-target="#matrica-supojavljivanja">Matrica supojavljivanja</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="txt-Reprezentacija-teksta.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li><li><a href="txt Reprezentacija teksta.docx"><i class="bi bi-file-word"></i>MS Word</a></li></ul></div></nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Reprezentacija teksta</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="reprezentacija-teksta" class="level1">
<h1>Reprezentacija teksta</h1>
<p>Zamislimo istraživača koji želi usporediti kako tri vodeća hrvatska informativna portala izvještavaju o klimatskim promjenama. Na raspolaganju mu je korpus od nekoliko tisuća članaka prikupljenih tijekom jednogodišnjeg razdoblja. Nakon što je proveo tokenizaciju, uklonio stop-riječi i normalizirao tekst, suočava se s temeljnim pitanjem: kako pretvoriti ove tekstualne podatke u oblik koji će omogućiti sustavnu usporedbu i statističku analizu? Drugim riječima, kako reprezentirati tekst na način koji će računalu omogućiti prepoznavanje sličnosti i razlika između dokumenata, identificiranje karakterističnih tema za svaki portal te otkrivanje obrazaca u medijskom diskursu?</p>
<p><strong>Reprezentacija teksta</strong> odnosi se na postupke kojima se tekstualni podaci transformiraju u matematičke strukture, najčešće vektore ili matrice, pogodne za računalnu obradu. Ova transformacija predstavlja ključan korak jer kvaliteta reprezentacije izravno utječe na uspješnost svih naknadnih analitičkih postupaka. Loše odabrana reprezentacija može prikriti relevantne obrasce ili, suprotno, proizvesti artefakte koji ne odražavaju stvarne karakteristike teksta.</p>
<p>Temeljni izazov reprezentacije teksta proizlazi iz fundamentalne razlike između prirode jezika i zahtjeva kvantitativnih metoda. Jezik je semantički bogat, kontekstualno ovisan i inherentno višeznačan sustav u kojem značenje proizlazi iz složenih odnosa između riječi, rečenica i šireg diskursnog konteksta. S druge strane, statistički algoritmi zahtijevaju precizno definirane numeričke vrijednosti organizirane u pravilne strukture. Svaka reprezentacija stoga nužno uključuje određenu razinu pojednostavljenja i gubitka informacija, a istraživačev zadatak je odabrati pristup koji optimalno balansira između računalne učinkovitosti i očuvanja semantički relevantnih svojstava teksta.</p>
<p>U ovom poglavlju razmatramo tri temeljne metode reprezentacije teksta koje čine konceptualnu osnovu za većinu naprednih tehnika analize. Započinjemo s najjednostavnijim pristupom poznatim kao model vreće riječi, zatim prelazimo na sofisticiraniju mjeru TF-IDF koja uvodi koncept težinskih vrijednosti, te zaključujemo s matricom supojavljivanja koja omogućuje analizu semantičkih odnosa između riječi.</p>
<section id="bag-of-words-bow-vreća-riječi" class="level2">
<h2 class="anchored" data-anchor-id="bag-of-words-bow-vreća-riječi">Bag-of-Words (BoW) – Vreća riječi</h2>
<p>Model <strong>vreće riječi</strong>, poznat i pod engleskim nazivom <em>Bag-of-Words</em> ili skraćenicom BoW, predstavlja najjednostavniji i povijesno najraniji pristup reprezentaciji teksta za kvantitativnu analizu. Osnovna intuicija ovog modela proizlazi iz pretpostavke da se sadržaj dokumenta može aproksimirati jednostavnim prebrojavanjem riječi koje se u njemu pojavljuju, pri čemu se potpuno zanemaruje redoslijed riječi i gramatička struktura. Metaforički rečeno, zamišljamo da sve riječi iz dokumenta ubacujemo u veliku vreću, miješamo ih i potom samo brojimo koliko puta se svaka riječ pojavljuje.</p>
<p>Premda se ova pretpostavka može činiti drastičnim pojednostavljenjem, praksa je pokazala da za mnoge analitičke zadatke takva reprezentacija pruža iznenađujuće dobre rezultate. Ako želimo klasificirati novinarske članke prema temama, činjenica da članak sadrži riječi poput “inflacija”, “kamatna stopa”, “BDP” i “proračun” snažno sugerira da se radi o ekonomskoj tematici, neovisno o tome kojim redoslijedom se te riječi pojavljuju u tekstu. Slično tome, visoka frekvencija riječi poput “utakmica”, “gol”, “prvak” i “reprezentacija” pouzdano identificira sportski sadržaj.</p>
<p>Formalno, model vreće riječi reprezentira korpus dokumenata pomoću <strong>matrice dokument-termin</strong> (engl. <em>document-term matrix</em>, skraćeno DTM). Radi se o matrici u kojoj svaki redak predstavlja jedan dokument, svaki stupac predstavlja jednu jedinstvenu riječ iz cjelokupnog vokabulara korpusa, a vrijednost u svakoj ćeliji označava frekvenciju pojavljivanja te riječi u tom dokumentu. Ako imamo korpus od <span class="math inline">\(m\)</span> dokumenata i vokabular od <span class="math inline">\(n\)</span> jedinstvenih riječi, rezultirajuća matrica ima dimenzije <span class="math inline">\(m \times n\)</span>.</p>
<p>Zamislimo konkretan primjer s tri kratka naslova novinskih članaka: “Vlada najavljuje nove porezne reforme”, “Premijer najavljuje reforme zdravstvenog sustava” i “Nove mjere za poticanje gospodarstva”. Nakon tokenizacije i pretvaranja u mala slova, gradimo vokabular koji uključuje sve jedinstvene riječi iz sva tri dokumenta. Matrica dokument-termin za ovaj mini-korpus izgledala bi otprilike ovako:</p>
<table class="caption-top table">
<caption>Primjer matrice dokument-termin za tri kratka dokumenta</caption>
<colgroup>
<col style="width: 8%">
<col style="width: 5%">
<col style="width: 10%">
<col style="width: 5%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 8%">
<col style="width: 11%">
<col style="width: 7%">
<col style="width: 5%">
<col style="width: 9%">
<col style="width: 11%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Dokument</th>
<th style="text-align: center;">vlada</th>
<th style="text-align: center;">najavljuje</th>
<th style="text-align: center;">nove</th>
<th style="text-align: center;">porezne</th>
<th style="text-align: center;">reforme</th>
<th style="text-align: center;">premijer</th>
<th style="text-align: center;">zdravstvenog</th>
<th style="text-align: center;">sustava</th>
<th style="text-align: center;">mjere</th>
<th style="text-align: center;">poticanje</th>
<th style="text-align: center;">gospodarstva</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">D1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">D2</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">D3</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>Iz ove matrice možemo iščitati nekoliko informacija. Dokumenti D1 i D2 dijele riječi “najavljuje” i “reforme”, što sugerira određenu tematsku sličnost. Dokument D3 nema preklapanja s ostala dva dokumenta u pogledu specifičnih riječi, premda svi govore o nekoj vrsti ekonomske ili političke aktivnosti. Valja primijetiti da je većina ćelija u matrici jednaka nuli jer svaki dokument koristi samo mali podskup ukupnog vokabulara.</p>
<p>Upravo ova karakteristika, poznata kao <strong>rijetka popunjenost</strong> ili sparsnost matrice, postaje izazov pri radu s većim korpusima. U realističnom scenariju analize medijskog sadržaja korpus može sadržavati desetke tisuća dokumenata i vokabular od stotina tisuća jedinstvenih riječi. Rezultirajuća matrica ima milijarde ćelija od kojih je više od 99% jednako nuli. Takve matrice zahtijevaju specijalizirane strukture za pohranu i algoritme za obradu koji učinkovito rukuju rijetkim podacima.</p>
<p>Usprkos svojoj jednostavnosti, model vreće riječi ima nekoliko inherentnih ograničenja. Najočitije je potpuni gubitak informacije o redoslijedu riječi. Rečenice “Čovjek je ugrizao psa” i “Pas je ugrizao čovjeka” imale bi identičnu reprezentaciju u modelu vreće riječi premda nose dijametralno suprotna značenja. Slično tome, negacije poput “nije dobro” gube svoj semantički učinak jer se “nije” i “dobro” tretiraju kao nezavisne jedinice. Za istraživanja koja se fokusiraju na tematsku klasifikaciju ili općenitu usporedbu sadržaja ova ograničenja često nisu kritična, no za finije analize poput analize sentimenata ili retoričkih strategija model vreće riječi može se pokazati nedostatnim.</p>
</section>
<section id="tf-idf-term-frequency-inverse-document-frequency" class="level2">
<h2 class="anchored" data-anchor-id="tf-idf-term-frequency-inverse-document-frequency">TF-IDF (Term Frequency – Inverse Document Frequency)</h2>
<p>Model vreće riječi tretira sve riječi kao jednako važne, što ne odgovara intuiciji o tome kako funkcionira značenje u tekstu. Neke riječi poput “je”, “u” ili “na” pojavljuju se vrlo često u gotovo svim tekstovima i nose malo informacije o specifičnom sadržaju dokumenta. S druge strane, riječi koje se pojavljuju rjeđe, ali konzistentno unutar određenog dokumenta, često su upravo one koje definiraju njegovu tematsku posebnost. Istraživač koji analizira korpus članaka o različitim temama želi identificirati koje riječi najbolje karakteriziraju svaki pojedini dokument, odnosno koje su riječi “potpis” pojedinog teksta.</p>
<p><strong>TF-IDF</strong> (skraćenica od engl. <em>Term Frequency – Inverse Document Frequency</em>) predstavlja statističku mjeru koja pokušava kvantificirati upravo tu intuiciju o važnosti riječi. Osnovna ideja je da riječ treba imati visoku težinu ako se često pojavljuje u određenom dokumentu, ali rijetko u ostalim dokumentima korpusa. Takva riječ vjerojatno nosi važnu informaciju o specifičnom sadržaju tog dokumenta. Suprotno tome, riječ koja se pojavljuje u gotovo svim dokumentima, bez obzira na to koliko često, ima nisku diskriminacijsku vrijednost i treba joj dodijeliti manju težinu.</p>
<p>Mjera TF-IDF sastoji se od dva komponenta. Prvi komponenta, <strong>frekvencija termina</strong> (TF), jednostavno mjeri koliko se često određena riječ pojavljuje u dokumentu. Može se izraziti kao sirovi broj pojavljivanja ili, češće, kao relativna frekvencija dobivena dijeljenjem broja pojavljivanja s ukupnim brojem riječi u dokumentu. Formalno, za riječ <span class="math inline">\(t\)</span> u dokumentu <span class="math inline">\(d\)</span>:</p>
<p><span class="math display">\[TF(t, d) = \frac{f_{t,d}}{\sum_{t' \in d} f_{t',d}}\]</span></p>
<p>gdje <span class="math inline">\(f_{t,d}\)</span> označava broj pojavljivanja riječi <span class="math inline">\(t\)</span> u dokumentu <span class="math inline">\(d\)</span>, a nazivnik predstavlja ukupan broj riječi u dokumentu.</p>
<p>Drugi komponenta, <strong>inverzna frekvencija dokumenta</strong> (IDF), mjeri koliko je riječ rijetka ili česta u cijelom korpusu. Definira se kao logaritam omjera ukupnog broja dokumenata i broja dokumenata koji sadrže tu riječ:</p>
<p><span class="math display">\[IDF(t, D) = \ln\left(\frac{N}{|\{d \in D : t \in d\}|}\right)\]</span></p>
<p>gdje <span class="math inline">\(N\)</span> označava ukupan broj dokumenata u korpusu <span class="math inline">\(D\)</span>, a nazivnik broji koliko dokumenata sadrži riječ <span class="math inline">\(t\)</span>. Logaritamska transformacija služi ublažavanju ekstremnih vrijednosti.</p>
<p>Konačna vrijednost TF-IDF dobiva se množenjem ova dva komponenta:</p>
<p><span class="math display">\[TF\text{-}IDF(t, d, D) = TF(t, d) \times IDF(t, D)\]</span></p>
<p>Promotrimo što ova formula implicira. Riječ koja se često pojavljuje u jednom dokumentu, ali rijetko u ostalima, imat će visoku vrijednost TF-IDF jer će oba faktora biti visoka. Riječ koja se pojavljuje u svim dokumentima imat će IDF jednak nuli (jer je logaritam od 1 jednak nuli), pa će njezina TF-IDF vrijednost također biti nula bez obzira na to koliko se često pojavljuje. Na taj način mjera automatski neutralizira utjecaj općenitih, visokofrekventnih riječi.</p>
<p>Za istraživača masovne komunikacije TF-IDF nudi mogućnost identificiranja <strong>karakterističnih riječi</strong> za pojedine medije, autore ili vremenska razdoblja. Primjerice, ako analiziramo članke različitih hrvatskih portala, visoke TF-IDF vrijednosti mogu otkriti terminologiju koju preferira svaki portal. Jedan portal možda češće koristi termine poput “građani” i “zajednica”, dok drugi preferira “potrošači” i “tržište”, što može ukazivati na različite ideološke okvire ili ciljane publike.</p>
<p>Tablica 1 prikazuje hipotetski primjer TF-IDF vrijednosti za odabrane riječi u tri dokumenta o ekonomskoj tematici.</p>
<table class="caption-top table">
<caption>Hipotetske TF-IDF vrijednosti za odabrane riječi u tri ekonomska teksta</caption>
<colgroup>
<col style="width: 9%">
<col style="width: 32%">
<col style="width: 33%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Riječ</th>
<th style="text-align: center;">D1 (Fiskalna politika)</th>
<th style="text-align: center;">D2 (Monetarna politika)</th>
<th style="text-align: center;">D3 (Opći pregled)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">proračun</td>
<td style="text-align: center;">0.089</td>
<td style="text-align: center;">0.012</td>
<td style="text-align: center;">0.031</td>
</tr>
<tr class="even">
<td style="text-align: left;">deficit</td>
<td style="text-align: center;">0.076</td>
<td style="text-align: center;">0.008</td>
<td style="text-align: center;">0.022</td>
</tr>
<tr class="odd">
<td style="text-align: left;">kamatna</td>
<td style="text-align: center;">0.011</td>
<td style="text-align: center;">0.094</td>
<td style="text-align: center;">0.028</td>
</tr>
<tr class="even">
<td style="text-align: left;">inflacija</td>
<td style="text-align: center;">0.023</td>
<td style="text-align: center;">0.081</td>
<td style="text-align: center;">0.035</td>
</tr>
<tr class="odd">
<td style="text-align: left;">gospodarstvo</td>
<td style="text-align: center;">0.018</td>
<td style="text-align: center;">0.021</td>
<td style="text-align: center;">0.019</td>
</tr>
<tr class="even">
<td style="text-align: left;">ekonomija</td>
<td style="text-align: center;">0.015</td>
<td style="text-align: center;">0.017</td>
<td style="text-align: center;">0.016</td>
</tr>
</tbody>
</table>
<p>Iz tablice vidimo da riječi “proračun” i “deficit” imaju najviše vrijednosti u dokumentu D1 koji se bavi fiskalnom politikom, dok “kamatna” i “inflacija” dominiraju u D2 o monetarnoj politici. Riječi “gospodarstvo” i “ekonomija” imaju slične, relativno niske vrijednosti u sva tri dokumenta jer se pojavljuju u svima i nemaju diskriminacijsku snagu. Ovakva analiza omogućuje istraživaču da brzo identificira tematski fokus svakog dokumenta te prepozna termine koji ga razlikuju od ostalih.</p>
<p>Valja napomenuti da TF-IDF, unatoč širokoj primjeni, ostaje heuristička mjera bez čvrste teorijske utemeljenosti u informacijskoj teoriji. Različite varijante formule koriste se u praksi, uključujući logaritamsko skaliranje frekvencije termina ili dodavanje konstanti za izbjegavanje dijeljenja s nulom. Izbor konkretne varijante ovisi o karakteristikama korpusa i specifičnostima analitičkog zadatka.</p>
</section>
<section id="matrica-supojavljivanja" class="level2">
<h2 class="anchored" data-anchor-id="matrica-supojavljivanja">Matrica supojavljivanja</h2>
<p>Prethodno razmatrane metode reprezentacije fokusirale su se na odnos između riječi i dokumenata, tretirajući svaku riječ kao nezavisnu jedinicu. Međutim, značenje riječi u prirodnom jeziku uvelike ovisi o kontekstu u kojem se pojavljuje i o drugim riječima s kojima se redovito javlja zajedno. Lingvistička hipoteza distribucijske semantike, koju je formulirao Zellig Harris sredinom dvadesetog stoljeća, tvrdi da riječi koje se pojavljuju u sličnim kontekstima imaju slična značenja. Ova intuicija motivira pristup reprezentaciji teksta temeljen na analizi <strong>supojavljivanja</strong> (engl. <em>co-occurrence</em>) riječi.</p>
<p><strong>Matrica supojavljivanja</strong> bilježi koliko se često parovi riječi pojavljuju zajedno unutar definiranog kontekstualnog prozora. Za razliku od matrice dokument-termin gdje redci predstavljaju dokumente, u matrici supojavljivanja i redci i stupci predstavljaju riječi iz vokabulara. Vrijednost u ćeliji <span class="math inline">\((i, j)\)</span> označava koliko se puta riječ <span class="math inline">\(i\)</span> pojavila u neposrednoj blizini riječi <span class="math inline">\(j\)</span> u cijelom korpusu. Veličina kontekstualnog prozora, najčešće definirana kao određeni broj riječi prije i poslije ciljne riječi, parametar je koji istraživač mora odrediti ovisno o analitičkim ciljevima.</p>
<p>Zamislimo da analiziramo korpus novinskih članaka o hrvatskom turizmu i definiramo kontekstualni prozor od dvije riječi s obje strane. Ako se u tekstu često pojavljuju fraze poput “turistička sezona”, “ljetna sezona”, “zimska sezona”, matrica supojavljivanja će zabilježiti visoke vrijednosti za parove (turistička, sezona), (ljetna, sezona) i (zimska, sezona). Slično tome, ako se “Dubrovnik” često pojavljuje u blizini riječi “zidine”, “Stari grad”, “kulturna baština”, te asocijacije bit će vidljive u matrici.</p>
<p>Ključna prednost matrice supojavljivanja jest što omogućuje otkrivanje <strong>semantičkih odnosa</strong> između riječi. Riječi koje se pojavljuju u sličnim kontekstima imat će slične profile supojavljivanja, odnosno slične retke u matrici. To znači da možemo mjeriti semantičku sličnost između riječi usporedbom njihovih vektora supojavljivanja. Kosinusna sličnost ili drugi mjere udaljenosti mogu otkriti da su “automobil” i “vozilo” semantički bliski jer se pojavljuju s istim skupom riječi poput “parkirati”, “voziti”, “autocesta”, premda se rijetko pojavljuju neposredno jedan pored drugog.</p>
<p>Za istraživanje masovne komunikacije matrica supojavljivanja otvara mogućnosti analize koje nadilaze jednostavno prebrojavanje riječi. Možemo istraživati kako mediji konceptualno povezuju različite pojmove, primjerice koje se riječi najčešće pojavljuju uz “migranti” u konzervativnim naspram liberalnih medija. Takva analiza može otkriti različite okvire predstavljanja istog fenomena, pri čemu jedni mediji asociraju migrante s terminima poput “sigurnost”, “granica”, “kontrola”, dok drugi koriste termine poput “humanitarni”, “pomoć”, “integracija”.</p>
<p>Praktična implementacija matrice supojavljivanja suočava se s izazovom dimenzionalnosti. Za vokabular od samo deset tisuća riječi rezultirajuća matrica ima sto milijuna ćelija. Upravo zato se u praksi često primjenjuju tehnike <strong>redukcije dimenzionalnosti</strong> poput dekompozicije singularnih vrijednosti (SVD) koja komprimira informacije iz velike rijetke matrice u gušću matricu nižih dimenzija. Ovaj postupak, poznat pod nazivom latentna semantička analiza (LSA), producira vektorske reprezentacije riječi koje zadržavaju semantičke odnose, ali u kompaktnijem obliku.</p>
<p>Tablica 2 prikazuje hipotetski isječak matrice supojavljivanja za mali skup riječi iz korpusa o ekonomiji.</p>
<table class="caption-top table">
<caption>Hipotetski isječak matrice supojavljivanja za ekonomski vokabular</caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: center;">rast</th>
<th style="text-align: center;">pad</th>
<th style="text-align: center;">gospodarstvo</th>
<th style="text-align: center;">inflacija</th>
<th style="text-align: center;">plaće</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">rast</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;">87</td>
<td style="text-align: center;">23</td>
<td style="text-align: center;">45</td>
</tr>
<tr class="even">
<td style="text-align: left;">pad</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">65</td>
<td style="text-align: center;">34</td>
<td style="text-align: center;">38</td>
</tr>
<tr class="odd">
<td style="text-align: left;">gospodarstvo</td>
<td style="text-align: center;">87</td>
<td style="text-align: center;">65</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">41</td>
<td style="text-align: center;">52</td>
</tr>
<tr class="even">
<td style="text-align: left;">inflacija</td>
<td style="text-align: center;">23</td>
<td style="text-align: center;">34</td>
<td style="text-align: center;">41</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">28</td>
</tr>
<tr class="odd">
<td style="text-align: left;">plaće</td>
<td style="text-align: center;">45</td>
<td style="text-align: center;">38</td>
<td style="text-align: center;">52</td>
<td style="text-align: center;">28</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<p>Iz tablice možemo iščitati da se “rast” i “gospodarstvo” vrlo često pojavljuju zajedno (87 supojavljivanja), dok “rast” i “pad” supostoje znatno rjeđe (12), što je očekivano jer se radi o antonimima koji se rijetko koriste u istom kontekstu. Zanimljivo je primijetiti da “gospodarstvo” ima visoke vrijednosti supojavljivanja sa svim ostalim riječima jer je to općeniti termin koji se prirodno kombinira s raznim ekonomskim konceptima.</p>
<p>Matrica supojavljivanja može se vizualizirati kao mreža ili graf u kojem čvorovi predstavljaju riječi, a bridovi povezuju riječi koje se često pojavljuju zajedno. Debljina ili boja bridova može kodirati jačinu asocijacije. Takve vizualizacije posebno su korisne za eksplorativnu analizu i komunikaciju rezultata široj publici jer omogućuju intuitivno razumijevanje semantičke strukture korpusa.</p>
<p>Valja zaključiti da različite metode reprezentacije teksta nude komplementarne perspektive na tekstualne podatke. Model vreće riječi pruža jednostavan i robustan temelj za mnoge analitičke zadatke. TF-IDF nadograđuje taj temelj uvođenjem koncepta težina koje reflektiraju diskriminacijsku vrijednost riječi. Matrica supojavljivanja otvara prozor u semantičke odnose koji definiraju značenje riječi u kontekstu. Izbor metode ovisi o specifičnostima istraživačkog pitanja, karakteristikama korpusa i računalnim resursima. U praksi se ove metode često kombiniraju ili služe kao polazište za naprednije tehnike poput tematskog modeliranja ili strojnog učenja.</p>
<table class="caption-top table">
<caption>Usporedba metoda reprezentacije teksta</caption>
<colgroup>
<col style="width: 16%">
<col style="width: 22%">
<col style="width: 22%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Metoda</th>
<th style="text-align: left;">Struktura</th>
<th style="text-align: left;">Što mjeri</th>
<th style="text-align: left;">Tipična primjena</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Vreća riječi (BoW)</td>
<td style="text-align: left;">Matrica dokument-termin</td>
<td style="text-align: left;">Frekvencija riječi u dokumentima</td>
<td style="text-align: left;">Klasifikacija dokumenata, pretraživanje</td>
</tr>
<tr class="even">
<td style="text-align: left;">TF-IDF</td>
<td style="text-align: left;">Matrica dokument-termin s težinama</td>
<td style="text-align: left;">Važnost riječi za dokument u korpusu</td>
<td style="text-align: left;">Identificiranje ključnih termina, usporedba dokumenata</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Matrica supojavljivanja</td>
<td style="text-align: left;">Matrica riječ-riječ</td>
<td style="text-align: left;">Kontekstualna bliskost riječi</td>
<td style="text-align: left;">Semantička analiza, analiza diskursa</td>
</tr>
</tbody>
</table>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>